#### 트랜잭션 ACID

- `Atomicity` : 트랜잭션에서 실행한 작업은 모두 실패하거나 모두 성공해야 한다.
- `Consistency` : 모든 트랜잭션은 일관성 있는 DB 상태를 유지해야 한다.
- `Isolation` : 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않도록 격리한다.
- `Durability` : 트랜잭션이 성공적으로 수행되면 그 결과는 영구히 반영되어야 한다.



###### 트랜잭션 격리 수준

- READ UNCOMMITED
- READ COMMITED
- REPEATABLE READ
- SEREALIZABLE



###### DB 연결 구조

1. 클라이언트에서 DB 접속 요청
2. connection 맺고 DB 서버에서 세션 생성 및 connection 등록
3. 등록된 connection에 의한 요청은 모두 세션에서 실행됨
4. 세션은 트랜잭션을 시작하고, 종료한다.

즉, 10개의 connection이 맺어지면 DB 서버에도 10개의 세션이 생성된다.



#### 스프링 트랜잭션 추상화

- JDBC, JPA는 트랜잭션을 시작, 종료, 롤백 하는 방식이 다르다. 따라서, 이 기능을 하는 트랜잭션 매니저를 추상화해서 사용한다.
- `PlatformTransactionManager`
  - 트랜잭션 매니저에서 DataSource를 사용해서 커넥션을 생성하고 트랜잭션 동기화 매니저에 보관한다.



#### 트랜잭션 동기화

트랜잭션 매니저는 크게 2가지 역할을 한다.

- 트랜잭션 추상화
- 리소스 동기화
  - 트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 connection을 유지해야 한다.



###### 트랜잭션 동기화 매니저

- `org.springframework.transaction.support.TransactionSynchronizationManager`

- 쓰레드 로컬을 사용해서 커넥션을 동기화 해준다. 트랜잭션 매니저는 내부에서 트랜잭션 동기화 매니저를 사용
  - 쓰레드 로컬 : 쓰레드 별로 별도의 공간을 가짐
- 멀티 쓰레드 상황에서 안전하게 커넥션을 동기화 할 수 있다.



######  동작 방식

1. 트랜잭션 매니저는 데이터 소스를 통해 커넥션을 만들고 커넥션을 시작
2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관
3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용
4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.



#### @Transactional

프록시를 적용해서 트랜잭션 처리 로직과 비즈니스 로직을 분리한다. 프록시에서 트랜잭션 관련 처리를 담당하고, 실제 비즈니스 로직을 호출한다.

이렇게 함으로써, 비즈니스 로직을 작성하는 서비스 영역에는 트랜잭션 처리 코드가 필요 없고, 비즈니스 로직 작성에만 집중할 수 있다

- `@Transactional`이 적용된 클래스는 **프록시**가 적용된다.



######  동작 순서

1. 클라이언트가 프록시 호출
2. 스프링 컨테이너를 통해 트랜잭션 매니저 획득
3. 트랜잭션 매니저에서 `getTransaction()` 메서드로 트랜잭션 시작
4. 커넥션 생성
5. `setAutoCommit(false)`
6. 트랜잭션 동기화 매너지에 커넥션 보관
7. 실제 비즈니스 로직 호출
8. 리포지토리에서 트랜잭션 동기화 매니저에 접근해 커넥션 획득



- **DataSource** : 커넥션 획득 방법
- **TransactionManager** : 트랜잭션 commit, rollback, begin 인터페이스, 트랜잭션 동기화 매니저
- **TransactionTemplate** : 트랜잭션 매니저로 처리하는 commit, rollback과 같은 반복 코드를 해결